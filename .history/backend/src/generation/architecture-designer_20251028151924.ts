 components.length * 5 + layers.length * 10);
    const scalability = 100 - complexity * 0.3;
    const maintainability = layers.length <= 4 ? 90 : 70;
    const quality = (scalability + maintainability) / 2;

    return {
      complexity,
      scalability: Math.max(0, scalability),
      maintainability,
      quality
    };
  }

  /**
   * Generate architecture recommendations
   */
  private generateRecommendations(style: ArchitectureStyle, metrics: any): string[] {
    const recommendations: string[] = [];

    if (metrics.complexity > 70) {
      recommendations.push('Consider breaking down complex components');
    }

    if (style === ArchitectureStyle.LAYERED) {
      recommendations.push('Implement clear separation of concerns between layers');
    }

    recommendations.push('Use dependency injection for better testability');
    recommendations.push('Implement comprehensive error handling');
    recommendations.push('Add logging and monitoring');

    return recommendations;
  }

  /**
   * Generate architecture documentation
   */
  private generateDocumentation(style: ArchitectureStyle, layers: LayerSpec[], components: ComponentSpec[]): string {
    return `
# Architecture Documentation

## Style
${style}

## Layers
${layers.map(l => `- ${l.name}: ${l.purpose}`).join('\\n')}

## Components
${components.map(c => `- ${c.name} (${c.type}): ${c.responsibilities[0]}`).join('\\n')}

## Design Principles
- Separation of concerns
- Single responsibility
- Dependency inversion
`.trim();
  }

  /**
   * Create safe fallback architecture
   */
  private createFallbackArchitecture(input: ArchitectureDesignInput): ArchitectureDesignResult {
    console.warn('[ArchitectureDesigner] Using fallback architecture');

    return {
      style: ArchitectureStyle.LAYERED,
      layers: [
        {
          name: 'Presentation',
          purpose: 'API endpoints',
          components: ['Controllers'],
          patterns: ['REST API']
        },
        {
          name: 'Business',
          purpose: 'Business logic',
          components: ['Services'],
          patterns: ['Service Pattern']
        }
      ],
      components: [
        {
          name: 'ItemController',
          type: 'controller',
          layer: 'Presentation',
          responsibilities: ['Handle HTTP requests'],
          dependencies: ['ItemService'],
          files: [{
            path: 'src/controllers',
            filename: 'ItemController.ts',
            content: this.generateControllerCode('Item', 'item')
          }]
        },
        {
          name: 'ItemService',
          type: 'service',
          layer: 'Business',
          responsibilities: ['Business logic'],
          dependencies: [],
          files: [{
            path: 'src/services',
            filename: 'ItemService.ts',
            content: this.generateServiceCode('Item', 'item')
          }]
        }
      ],
      patterns: ['MVC', 'REST API'],
      integrations: ['Express Backend'],
      metrics: {
        complexity: 20,
        scalability: 80,
        maintainability: 85,
        quality: 82
      },
      recommendations: ['Implement proper error handling'],
      documentation: '# Basic Architecture\\n\\nStandard layered architecture with controllers and services.'
    };
  }

  /**
   * Capitalize first letter
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // ═══════════════════════════════════════════════════════════════
  // 🆕 CODE GENERATION METHODS - v3.0
  // ═══════════════════════════════════════════════════════════════

  /**
   * Generate Controller code (TypeScript + Express)
   */
  private generateControllerCode(entityName: string, entity: string): string {
    return `import { Request, Response } from 'express';
import { ${entityName}Service } from '../services/${entityName}Service';

/**
 * ${entityName} Controller
 * Handles HTTP requests for ${entity} operations
 * 
 * @generated by ORUS Builder v3.0
 */
export class ${entityName}Controller {
  private ${entity.toLowerCase()}Service: ${entityName}Service;

  constructor() {
    this.${entity.toLowerCase()}Service = new ${entityName}Service();
  }

  /**
   * Get all ${entity}s
   * @route GET /api/${entity.toLowerCase()}
   */
  async getAll(req: Request, res: Response): Promise<void> {
    try {
      const items = await this.${entity.toLowerCase()}Service.findAll();
      res.json({
        success: true,
        data: items,
        count: items.length
      });
    } catch (error) {
      console.error(\`[${entityName}Controller] Error in getAll:\`, error);
      res.status(500).json({
        success: false,
        error: (error as Error).message
      });
    }
  }

  /**
   * Get ${entity} by ID
   * @route GET /api/${entity.toLowerCase()}/:id
   */
  async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const item = await this.${entity.toLowerCase()}Service.findById(id);
      
      if (!item) {
        res.status(404).json({
          success: false,
          error: '${entityName} not found'
        });
        return;
      }
      
      res.json({
        success: true,
        data: item
      });
    } catch (error) {
      console.error(\`[${entityName}Controller] Error in getById:\`, error);
      res.status(500).json({
        success: false,
        error: (error as Error).message
      });
    }
  }

  /**
   * Create new ${entity}
   * @route POST /api/${entity.toLowerCase()}
   */
  async create(req: Request, res: Response): Promise<void> {
    try {
      const item = await this.${entity.toLowerCase()}Service.create(req.body);
      res.status(201).json({
        success: true,
        data: item,
        message: '${entityName} created successfully'
      });
    } catch (error) {
      console.error(\`[${entityName}Controller] Error in create:\`, error);
      res.status(400).json({
        success: false,
        error: (error as Error).message
      });
    }
  }

  /**
   * Update ${entity}
   * @route PUT /api/${entity.toLowerCase()}/:id
   */
  async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const item = await this.${entity.toLowerCase()}Service.update(id, req.body);
      res.json({
        success: true,
        data: item,
        message: '${entityName} updated successfully'
      });
    } catch (error) {
      console.error(\`[${entityName}Controller] Error in update:\`, error);
      res.status(400).json({
        success: false,
        error: (error as Error).message
      });
    }
  }

  /**
   * Delete ${entity}
   * @route DELETE /api/${entity.toLowerCase()}/:id
   */
  async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      await this.${entity.toLowerCase()}Service.delete(id);
      res.status(204).send();
    } catch (error) {
      console.error(\`[${entityName}Controller] Error in delete:\`, error);
      res.status(500).json({
        success: false,
        error: (error as Error).message
      });
    }
  }
}

export default new ${entityName}Controller();
`;
  }

  /**
   * Generate Service code (TypeScript + Business Logic)
   */
  private generateServiceCode(entityName: string, entity: string): string {
    return `import { ${entityName}Repository } from '../repositories/${entityName}Repository';

/**
 * ${entityName} Interface
 */
export interface ${entityName} {
  id: string;
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * ${entityName} Service
 * Implements business logic for ${entity} operations
 * 
 * @generated by ORUS Builder v3.0
 */
export class ${entityName}Service {
  private ${entity.toLowerCase()}Repository: ${entityName}Repository;

  constructor() {
    this.${entity.toLowerCase()}Repository = new ${entityName}Repository();
  }

  /**
   * Find all ${entity}s
   */
  async findAll(): Promise<${entityName}[]> {
    return this.${entity.toLowerCase()}Repository.findAll();
  }

  /**
   * Find ${entity} by ID
   */
  async findById(id: string): Promise<${entityName} | null> {
    if (!id || id.trim() === '') {
      throw new Error('ID is required');
    }
    return this.${entity.toLowerCase()}Repository.findById(id);
  }

  /**
   * Create new ${entity}
   */
  async create(data: Partial<${entityName}>): Promise<${entityName}> {
    // Validation
    if (!data.name || data.name.trim() === '') {
      throw new Error('Name is required');
    }

    if (data.name.length < 2) {
      throw new Error('Name must be at least 2 characters long');
    }

    // Business logic
    const ${entity.toLowerCase()}Data = {
      ...data,
      name: data.name.trim(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return this.${entity.toLowerCase()}Repository.create(${entity.toLowerCase()}Data);
  }

  /**
   * Update ${entity}
   */
  async update(id: string, data: Partial<${entityName}>): Promise<${entityName}> {
    if (!id || id.trim() === '') {
      throw new Error('ID is required');
    }

    // Check if exists
    const existing = await this.findById(id);
    if (!existing) {
      throw new Error('${entityName} not found');
    }

    // Validation
    if (data.name !== undefined) {
      if (data.name.trim() === '') {
        throw new Error('Name cannot be empty');
      }
      if (data.name.length < 2) {
        throw new Error('Name must be at least 2 characters long');
      }
    }

    // Update data
    const updateData = {
      ...data,
      name: data.name?.trim(),
      updatedAt: new Date()
    };

    return this.${entity.toLowerCase()}Repository.update(id, updateData);
  }

  /**
   * Delete ${entity}
   */
  async delete(id: string): Promise<void> {
    if (!id || id.trim() === '') {
      throw new Error('ID is required');
    }

    // Check if exists
    const existing = await this.findById(id);
    if (!existing) {
      throw new Error('${entityName} not found');
    }

    await this.${entity.toLowerCase()}Repository.delete(id);
  }

  /**
   * Count ${entity}s
   */
  async count(): Promise<number> {
    const items = await this.findAll();
    return items.length;
  }

  /**
   * Search ${entity}s by name
   */
  async search(query: string): Promise<${entityName}[]> {
    if (!query || query.trim() === '') {
      return this.findAll();
    }
    const allItems = await this.findAll();
    return allItems.filter(item => 
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }
}

export default new ${entityName}Service();
`;
  }

  /**
   * Generate Repository code (TypeScript + Prisma)
   */
  private generateRepositoryCode(entityName: string, entity: string): string {
    return `import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * ${entityName} Repository
 * Handles database operations for ${entity}
 * 
 * @generated by ORUS Builder v3.0
 */
export class ${entityName}Repository {
  /**
   * Find all ${entity}s
   */
  async findAll() {
    return prisma.${entity.toLowerCase()}.findMany({
      orderBy: {
        createdAt: 'desc'
      }
    });
  }

  /**
   * Find ${entity} by ID
   */
  async findById(id: string) {
    return prisma.${entity.toLowerCase()}.findUnique({
      where: { id }
    });
  }

  /**
   * Create ${entity}
   */
  async create(data: any) {
    return prisma.${entity.toLowerCase()}.create({
      data
    });
  }

  /**
   * Update ${entity}
   */
  async update(id: string, data: any) {
    return prisma.${entity.toLowerCase()}.update({
      where: { id },
      data
    });
  }

  /**
   * Delete ${entity}
   */
  async delete(id: string) {
    return prisma.${entity.toLowerCase()}.delete({
      where: { id }
    });
  }

  /**
   * Find ${entity} by name
   */
  async findByName(name: string) {
    return prisma.${entity.toLowerCase()}.findFirst({
      where: {
        name: {
          contains: name,
          mode: 'insensitive'
        }
      }
    });
  }

  /**
   * Count ${entity}s
   */
  async count() {
    return prisma.${entity.toLowerCase()}.count();
  }

  /**
   * Find many ${entity}s with pagination
   */
  async findMany(skip: number = 0, take: number = 10) {
    return prisma.${entity.toLowerCase()}.findMany({
      skip,
      take,
      orderBy: {
        createdAt: 'desc'
      }
    });
  }
}

export default new ${entityName}Repository();
`;
  }

  /**
   * Generate Auth Middleware code (TypeScript + JWT)
   */
  private generateAuthMiddlewareCode(): string {
    return `import { Request, Response, NextFunction } from 'express';
import * as jwt from 'jsonwebtoken';

/**
 * Auth Middleware
 * Verifies JWT tokens and protects routes
 * 
 * @generated by ORUS Builder v3.0
 */
export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        error: 'No token provided'
      });
      return;
    }

    const token = authHeader.substring(7);

    // Verify token
    const secret = process.env.JWT_SECRET || 'your-secret-key';
    const decoded = jwt.verify(token, secret);

    // Add user to request
    (req as any).user = decoded;

    next();
  } catch (error) {
    console.error('[AuthMiddleware] Error:', error);
    
    if (error instanceof jwt.TokenExpiredError) {
      res.status(401).json({
        success: false,
        error: 'Token expired'
      });
      return;
    }
    
    if (error instanceof jwt.JsonWebTokenError) {
      res.status(401).json({
        success: false,
        error: 'Invalid token'
      });
      return;
    }
    
    res.status(401).json({
      success: false,
      error: 'Authentication failed'
    });
  }
};

export default authMiddleware;
`;
  }
}

// ═══════════════════════════════════════════════════════════════
// SINGLETON EXPORT
// ═══════════════════════════════════════════════════════════════

export const architectureDesigner = new ArchitectureDesigner();
export default architectureDesigner;